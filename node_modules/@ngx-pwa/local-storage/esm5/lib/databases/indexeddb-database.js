/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, Optional, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first } from 'rxjs/operators';
import { LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Connects to IndexedDB
     */
    function IndexedDBDatabase(prefix) {
        if (prefix === void 0) { prefix = null; }
        this.prefix = prefix;
        /**
         * IndexedDB database name for local storage
         */
        this.dbName = 'ngStorage';
        /**
         * IndexedDB object store name for local storage
         */
        this.objectStoreName = 'localStorage';
        /**
         * IndexedDB key path name for local storage (where an item's key will be stored)
         */
        this.keyPath = 'key';
        /**
         * IndexedDB data path name for local storage (where items' value will be stored)
         */
        this.dataPath = 'value';
        if (prefix) {
            this.dbName = prefix + "_" + this.dbName;
        }
        /* Creating the RxJS ReplaySubject */
        this.database = new ReplaySubject();
        /* Connecting to IndexedDB */
        this.connect();
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        var _this = this;
        /* Opening a trasaction and requesting the item in local storage */
        return this.transaction().pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            var /** @type {?} */ success = (/** @type {?} */ (fromEvent(request, 'success'))).pipe(map(function (event) { return (/** @type {?} */ (event.target)).result; }), map(function (result) { return result && (_this.dataPath in result) ? (/** @type {?} */ (result[_this.dataPath])) : null; }));
            /* Merging success and errors events and autoclosing the observable */
            return (/** @type {?} */ (race(success, _this.toErrorObservable(request, "getter"))))
                .pipe(first());
        }), first());
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        var _this = this;
        /* Storing null is not correctly supported by IndexedDB and unnecessary here */
        if (data == null) {
            return of(true);
        }
        /* Opening a transaction and checking if the item already exists in local storage */
        return this.getItem(key).pipe(map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {
            /* Opening a transaction */
            return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                var /** @type {?} */ request;
                /* Adding or updating local storage, based on previous checking */
                switch (method) {
                    case 'add':
                        request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);
                        break;
                    case 'put':
                    default:
                        request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                        break;
                }
                /* Merging success (passing true) and error events and autoclosing the observable */
                return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter"))))
                    .pipe(first());
                var _a, _b;
            }));
        }), first());
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        var _this = this;
        /* Opening a transaction and checking if the item exists in local storage */
        return this.getItem(key).pipe(mergeMap(function (data) {
            /* If the item exists in local storage */
            if (data != null) {
                /* Opening a transaction */
                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    var /** @type {?} */ request = transaction.delete(key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover"))))
                        .pipe(first());
                }));
            }
            /* Passing true if the item does not exist in local storage */
            return of(true);
        }), first());
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        var _this = this;
        /* Opening a transaction */
        return this.transaction('readwrite').pipe(mergeMap(function (transaction) {
            /* Deleting all items from local storage */
            var /** @type {?} */ request = transaction.clear();
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer"))))
                .pipe(first());
        }), first());
    };
    /**
     * Connects to IndexedDB and creates the object store on first time
     */
    /**
     * Connects to IndexedDB and creates the object store on first time
     * @return {?}
     */
    IndexedDBDatabase.prototype.connect = /**
     * Connects to IndexedDB and creates the object store on first time
     * @return {?}
     */
    function () {
        var _this = this;
        /* Connecting to IndexedDB */
        var /** @type {?} */ request = indexedDB.open(this.dbName);
        /* Listening the event fired on first connection, creating the object store for local storage */
        (/** @type {?} */ (fromEvent(request, 'upgradeneeded')))
            .pipe(first())
            .subscribe(function (event) {
            /* Getting the database connection */
            var /** @type {?} */ database = /** @type {?} */ ((/** @type {?} */ (event.target)).result);
            /* Checking if the object store already exists, to avoid error */
            if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                /* Creating the object store for local storage */
                database.createObjectStore(_this.objectStoreName);
            }
        });
        /* Listening the success event and converting to an RxJS Observable */
        var /** @type {?} */ success = /** @type {?} */ (fromEvent(request, 'success'));
        /* Merging success and errors events */
        (/** @type {?} */ (race(success, this.toErrorObservable(request, "connection"))))
            .pipe(first())
            .subscribe(function (event) {
            /* Storing the database connection for further access */
            /* Storing the database connection for further access */
            _this.database.next(/** @type {?} */ ((/** @type {?} */ (event.target)).result));
        }, function (error) {
            _this.database.error(/** @type {?} */ (error));
        });
    };
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.transaction = /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    function (mode) {
        var _this = this;
        if (mode === void 0) { mode = 'readonly'; }
        /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
        return this.database
            .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
    };
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param request The request to listen
     * @returns A RxJS Observable with true value
     */
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    IndexedDBDatabase.prototype.toSuccessObservable = /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    function (request) {
        /* Transforming a IndexedDB success event in an RxJS Observable with true value */
        return (/** @type {?} */ (fromEvent(request, 'success')))
            .pipe(map(function () { return true; }));
    };
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param request The request to listen
     * @param error Optionnal details about the error's origin
     * @returns A RxJS ErrorObservable
     */
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    IndexedDBDatabase.prototype.toErrorObservable = /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    function (request, error) {
        if (error === void 0) { error = ""; }
        /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
        return (/** @type {?} */ (fromEvent(request, 'error')))
            .pipe(mergeMap(function () { return throwError(new Error("IndexedDB " + error + " issue : " + request.error.message + ".")); }));
    };
    IndexedDBDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    IndexedDBDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
    ]; };
    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = i0.defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.inject(i1.LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
    return IndexedDBDatabase;
}());
export { IndexedDBDatabase };
function IndexedDBDatabase_tsickle_Closure_declarations() {
    /**
     * IndexedDB database name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.dbName;
    /**
     * IndexedDB object store name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.objectStoreName;
    /**
     * IndexedDB key path name for local storage (where an item's key will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.keyPath;
    /**
     * IndexedDB data path name for local storage (where items' value will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.dataPath;
    /**
     * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection
     * even after the connection success event happened
     * @type {?}
     */
    IndexedDBDatabase.prototype.database;
    /** @type {?} */
    IndexedDBDatabase.prototype.prefix;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFjLGFBQWEsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEYsT0FBTyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFHdEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sV0FBVyxDQUFDOzs7O0lBNkIvQzs7T0FFRztJQUNILDJCQUFnRSxNQUE0Qjs4Q0FBQTtRQUE1QixXQUFNLEdBQU4sTUFBTSxDQUFzQjs7OztzQkF0QnpFLFdBQVc7Ozs7K0JBSU8sY0FBYzs7Ozt1QkFJdEIsS0FBSzs7Ozt3QkFJSixPQUFPO1FBWW5DLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFFWCxJQUFJLENBQUMsTUFBTSxHQUFNLE1BQU0sU0FBSSxJQUFJLENBQUMsTUFBUSxDQUFDO1NBRTFDOztRQUdELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxhQUFhLEVBQWUsQ0FBQzs7UUFHakQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBRWhCO0lBRUQ7Ozs7T0FJRzs7Ozs7OztJQUNILG1DQUFPOzs7Ozs7SUFBUCxVQUFpQixHQUFXO1FBQTVCLGlCQXFCQzs7UUFsQkMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQzVCLEdBQUcsQ0FBQyxVQUFDLFdBQVcsSUFBSyxPQUFBLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFD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QyxLQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUksQ0FBQyxlQUFlLENBQUMsRUFBcEYsQ0FBb0YsQ0FBQyxDQUFDLENBQUM7S0FFbEg7SUFFRDs7OztPQUlHOzs7Ozs7SUFDTywrQ0FBbUI7Ozs7O0lBQTdCLFVBQThCLE9BQW1COztRQUcvQyxNQUFNLENBQUMsbUJBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQXNCLEVBQUM7YUFDeEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFNLE9BQUEsSUFBSSxFQUFKLENBQUksQ0FBQyxDQUFDLENBQUM7S0FFMUI7SUFFRDs7Ozs7T0FLRzs7Ozs7OztJQUNPLDZDQUFpQjs7Ozs7O0lBQTNCLFVBQTRCLE9BQW1CLEVBQUUsS0FBVTtRQUFWLHNCQUFBLEVBQUEsVUFBVTs7UUFHekQsTUFBTSxDQUFDLG1CQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFzQixFQUFDO2FBQ3RELElBQUksQ0FBQyxRQUFRLENBQUMsY0FBTSxPQUFBLFVBQVUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxlQUFhLEtBQUssaUJBQVksT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQUcsQ0FBQyxDQUFDLEVBQTdFLENBQTZFLENBQUMsQ0FBQyxDQUFDO0tBRXhHOztnQkF6UUYsVUFBVSxTQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7OztnREE0QmMsUUFBUSxZQUFJLE1BQU0sU0FBQyxvQkFBb0I7Ozs0QkFyQ3REOztTQVVhLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIGZyb21FdmVudCwgb2YsIHRocm93RXJyb3IsIHJhY2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBMT0NBTF9TVE9SQUdFX1BSRUZJWCB9IGZyb20gJy4uL3Rva2Vucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEluZGV4ZWREQkRhdGFiYXNlIGltcGxlbWVudHMgTG9jYWxEYXRhYmFzZSB7XG5cbiAgLyoqXG4gICAqIEluZGV4ZWREQiBkYXRhYmFzZSBuYW1lIGZvciBsb2NhbCBzdG9yYWdlXG4gICAqL1xuICBwcm90ZWN0ZWQgZGJOYW1lID0gJ25nU3RvcmFnZSc7XG4gIC8qKlxuICAgKiBJbmRleGVkREIgb2JqZWN0IHN0b3JlIG5hbWUgZm9yIGxvY2FsIHN0b3JhZ2VcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBvYmplY3RTdG9yZU5hbWUgPSAnbG9jYWxTdG9yYWdlJztcbiAgLyoqXG4gICAqIEluZGV4ZWREQiBrZXkgcGF0aCBuYW1lIGZvciBsb2NhbCBzdG9yYWdlICh3aGVyZSBhbiBpdGVtJ3Mga2V5IHdpbGwgYmUgc3RvcmVkKVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGtleVBhdGggPSAna2V5JztcbiAgLyoqXG4gICAqIEluZGV4ZWREQiBkYXRhIHBhdGggbmFtZSBmb3IgbG9jYWwgc3RvcmFnZSAod2hlcmUgaXRlbXMnIHZhbHVlIHdpbGwgYmUgc3RvcmVkKVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFQYXRoID0gJ3ZhbHVlJztcbiAgLyoqXG4gICAqIEluZGV4ZWREQiBkYXRhYmFzZSBjb25uZWN0aW9uLCB3cmFwcGVkIGluIGEgUnhKUyBSZXBsYXlTdWJqZWN0IHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBjb25uZWN0aW9uXG4gICAqIGV2ZW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3VjY2VzcyBldmVudCBoYXBwZW5lZFxuICAgKi9cbiAgcHJvdGVjdGVkIGRhdGFiYXNlOiBSZXBsYXlTdWJqZWN0PElEQkRhdGFiYXNlPjtcblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gSW5kZXhlZERCXG4gICAqL1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KExPQ0FMX1NUT1JBR0VfUFJFRklYKSBwcm90ZWN0ZWQgcHJlZml4OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuXG4gICAgaWYgKHByZWZpeCkge1xuXG4gICAgICB0aGlzLmRiTmFtZSA9IGAke3ByZWZpeH1fJHt0aGlzLmRiTmFtZX1gO1xuXG4gICAgfVxuXG4gICAgLyogQ3JlYXRpbmcgdGhlIFJ4SlMgUmVwbGF5U3ViamVjdCAqL1xuICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT4oKTtcblxuICAgIC8qIENvbm5lY3RpbmcgdG8gSW5kZXhlZERCICovXG4gICAgdGhpcy5jb25uZWN0KCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gdmFsdWUgaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgZ2V0SXRlbTxUID0gYW55PihrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8VMKgfCBudWxsPiB7XG5cbiAgICAvKiBPcGVuaW5nIGEgdHJhc2FjdGlvbiBhbmQgcmVxdWVzdGluZyB0aGUgaXRlbSBpbiBsb2NhbCBzdG9yYWdlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oKS5waXBlKFxuICAgICAgbWFwKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZ2V0KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKHJlcXVlc3QpID0+IHtcblxuICAgICAgICAvKiBMaXN0ZW5pbmcgdG8gdGhlIHN1Y2Nlc3MgZXZlbnQsIGFuZCBwYXNzaW5nIHRoZSBpdGVtIHZhbHVlIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZSAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKGZyb21FdmVudChyZXF1ZXN0LCAnc3VjY2VzcycpIGFzIE9ic2VydmFibGU8RXZlbnQ+KS5waXBlKFxuICAgICAgICAgIG1hcCgoZXZlbnQpID0+IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0KSxcbiAgICAgICAgICBtYXAoKHJlc3VsdCkgPT4gcmVzdWx0ICYmICh0aGlzLmRhdGFQYXRoIGluIHJlc3VsdCkgPyAocmVzdWx0W3RoaXMuZGF0YVBhdGhdIGFzIFQpIDogbnVsbClcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgYW5kIGVycm9ycyBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgIHJldHVybiAocmFjZShzdWNjZXNzLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBnZXR0ZXJgKSkgYXMgT2JzZXJ2YWJsZTxUIHwgbnVsbD4pXG4gICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG5cbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWUsIG11c3QgTk9UIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBTdG9yaW5nIG51bGwgaXMgbm90IGNvcnJlY3RseSBzdXBwb3J0ZWQgYnkgSW5kZXhlZERCIGFuZCB1bm5lY2Vzc2FyeSBoZXJlICovXG4gICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuXG4gICAgICByZXR1cm4gb2YodHJ1ZSk7XG5cbiAgICB9XG5cbiAgICAvKiBPcGVuaW5nIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNraW5nIGlmIHRoZSBpdGVtIGFscmVhZHkgZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleSkucGlwZShcbiAgICAgIG1hcCgoZXhpc3RpbmdEYXRhKSA9PiAoZXhpc3RpbmdEYXRhID09IG51bGwpID8gJ2FkZCcgOiAncHV0JyksXG4gICAgICBtZXJnZU1hcCgobWV0aG9kKSA9PiB7XG5cbiAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKG1lcmdlTWFwKCh0cmFuc2FjdGlvbikgPT4ge1xuXG4gICAgICAgICAgbGV0IHJlcXVlc3Q6IElEQlJlcXVlc3Q7XG5cbiAgICAgICAgICAvKiBBZGRpbmcgb3IgdXBkYXRpbmcgbG9jYWwgc3RvcmFnZSwgYmFzZWQgb24gcHJldmlvdXMgY2hlY2tpbmcgKi9cbiAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLmFkZCh7IFt0aGlzLmRhdGFQYXRoXTogZGF0YSB9LCBrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXF1ZXN0ID0gdHJhbnNhY3Rpb24ucHV0KHsgW3RoaXMuZGF0YVBhdGhdOiBkYXRhIH0sIGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIE1lcmdpbmcgc3VjY2VzcyAocGFzc2luZyB0cnVlKSBhbmQgZXJyb3IgZXZlbnRzIGFuZCBhdXRvY2xvc2luZyB0aGUgb2JzZXJ2YWJsZSAqL1xuICAgICAgICAgIHJldHVybiAocmFjZSh0aGlzLnRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdCksIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYHNldHRlcmApKSBhcyBPYnNlcnZhYmxlPGJvb2xlYW4+KVxuICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG5cbiAgICAgICAgfSkpO1xuXG4gICAgICB9KSxcbiAgICAgIGZpcnN0KClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tpbmcgaWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleSkucGlwZShcbiAgICAgIG1lcmdlTWFwKChkYXRhKSA9PiB7XG5cbiAgICAgICAgLyogSWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuXG4gICAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUobWVyZ2VNYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgIC8qIERlbGV0aW5nIHRoZSBpdGVtIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIChwYXNzaW5nIHRydWUpIGFuZCBlcnJvciBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgICAgICByZXR1cm4gKHJhY2UodGhpcy50b1N1Y2Nlc3NPYnNlcnZhYmxlKHJlcXVlc3QpLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGByZW1vdmVyYCkpIGFzIE9ic2VydmFibGU8Ym9vbGVhbj4pXG4gICAgICAgICAgICAgIC5waXBlKGZpcnN0KCkpO1xuXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBQYXNzaW5nIHRydWUgaWYgdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3QgaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICByZXR1cm4gb2YodHJ1ZSk7XG5cbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBpdGVtcyBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQW4gUnhKUyBPYnNlcnZhYmxlIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgLyogRGVsZXRpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdHJhbnNhY3Rpb24uY2xlYXIoKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgKHBhc3NpbmcgdHJ1ZSkgYW5kIGVycm9yIGV2ZW50cyBhbmQgYXV0b2Nsb3NpbmcgdGhlIG9ic2VydmFibGUgKi9cbiAgICAgICAgcmV0dXJuIChyYWNlKHRoaXMudG9TdWNjZXNzT2JzZXJ2YWJsZShyZXF1ZXN0KSwgdGhpcy50b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0LCBgY2xlYXJlcmApKSBhcyBPYnNlcnZhYmxlPGJvb2xlYW4+KVxuICAgICAgICAgIC5waXBlKGZpcnN0KCkpO1xuXG4gICAgICB9KSxcbiAgICAgIGZpcnN0KClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gSW5kZXhlZERCIGFuZCBjcmVhdGVzIHRoZSBvYmplY3Qgc3RvcmUgb24gZmlyc3QgdGltZVxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbm5lY3QoKTogdm9pZCB7XG5cbiAgICAvKiBDb25uZWN0aW5nIHRvIEluZGV4ZWREQiAqL1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSk7XG5cbiAgICAvKiBMaXN0ZW5pbmcgdGhlIGV2ZW50IGZpcmVkIG9uIGZpcnN0IGNvbm5lY3Rpb24sIGNyZWF0aW5nIHRoZSBvYmplY3Qgc3RvcmUgZm9yIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAoZnJvbUV2ZW50KHJlcXVlc3QsICd1cGdyYWRlbmVlZGVkJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBHZXR0aW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uICovXG4gICAgICAgIGNvbnN0IGRhdGFiYXNlID0gKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2U7XG5cbiAgICAgICAgLyogQ2hlY2tpbmcgaWYgdGhlIG9iamVjdCBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgaWYgKCFkYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkge1xuXG4gICAgICAgICAgLyogQ3JlYXRpbmcgdGhlIG9iamVjdCBzdG9yZSBmb3IgbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICAgIGRhdGFiYXNlLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgLyogTGlzdGVuaW5nIHRoZSBzdWNjZXNzIGV2ZW50IGFuZCBjb252ZXJ0aW5nIHRvIGFuIFJ4SlMgT2JzZXJ2YWJsZSAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIC8qIE1lcmdpbmcgc3VjY2VzcyBhbmQgZXJyb3JzIGV2ZW50cyAqL1xuICAgIChyYWNlKHN1Y2Nlc3MsIHRoaXMudG9FcnJvck9ic2VydmFibGUocmVxdWVzdCwgYGNvbm5lY3Rpb25gKSkgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcblxuICAgICAgICAvKiBTdG9yaW5nIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIGFjY2VzcyAqL1xuICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQoKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQgYXMgSURCRGF0YWJhc2UpO1xuXG4gICAgICB9LCAoZXJyb3IpID0+IHtcblxuICAgICAgICB0aGlzLmRhdGFiYXNlLmVycm9yKGVycm9yIGFzIEVycm9yKTtcblxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gYW5kIGdldHMgdGhlIGxvY2FsIHN0b3JhZ2Ugb2JqZWN0IHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIERlZmF1bHQgdG8gJ3JlYWRvbmx5JyBmb3IgcmVhZCBvcGVyYXRpb25zLCBvciAncmVhZHdyaXRlJyBmb3Igd3JpdGUgb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJucyBBbiBJbmRleGVkREIgdHJhbnNhY3Rpb24gb2JqZWN0IHN0b3JlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6ICdyZWFkb25seScgfCAncmVhZHdyaXRlJyA9ICdyZWFkb25seScpOiBPYnNlcnZhYmxlPElEQk9iamVjdFN0b3JlPiB7XG5cbiAgICAvKiBGcm9tIHRoZSBJbmRleGVkREIgY29ubmVjdGlvbiwgb3BlbmluZyBhIHRyYW5zYWN0aW9uIGFuZCBnZXR0aW5nIHRoZSBsb2NhbCBzdG9yYWdlIG9iamV0IHN0b3JlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2VcbiAgICAgIC5waXBlKG1hcCgoZGF0YWJhc2UpID0+IGRhdGFiYXNlLnRyYW5zYWN0aW9uKFt0aGlzLm9iamVjdFN0b3JlTmFtZV0sIG1vZGUpLm9iamVjdFN0b3JlKHRoaXMub2JqZWN0U3RvcmVOYW1lKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIEluZGV4ZWREQiBzdWNjZXNzIGV2ZW50IGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlXG4gICAqL1xuICBwcm90ZWN0ZWQgdG9TdWNjZXNzT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBUcmFuc2Zvcm1pbmcgYSBJbmRleGVkREIgc3VjY2VzcyBldmVudCBpbiBhbiBSeEpTIE9ic2VydmFibGUgd2l0aCB0cnVlIHZhbHVlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKSBhcyBPYnNlcnZhYmxlPEV2ZW50PilcbiAgICAgIC5waXBlKG1hcCgoKSA9PiB0cnVlKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlXG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSByZXF1ZXN0IHRvIGxpc3RlblxuICAgKiBAcGFyYW0gZXJyb3IgT3B0aW9ubmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yJ3Mgb3JpZ2luXG4gICAqIEByZXR1cm5zIEEgUnhKUyBFcnJvck9ic2VydmFibGVcbiAgICovXG4gIHByb3RlY3RlZCB0b0Vycm9yT2JzZXJ2YWJsZShyZXF1ZXN0OiBJREJSZXF1ZXN0LCBlcnJvciA9IGBgKTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgLyogVHJhbnNmb3JtaW5nIGEgSW5kZXhlZERCIGVycm9yIGV2ZW50IGluIGFuIFJ4SlMgRXJyb3JPYnNlcnZhYmxlICovXG4gICAgcmV0dXJuIChmcm9tRXZlbnQocmVxdWVzdCwgJ2Vycm9yJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShtZXJnZU1hcCgoKSA9PiB0aHJvd0Vycm9yKG5ldyBFcnJvcihgSW5kZXhlZERCICR7ZXJyb3J9IGlzc3VlIDogJHtyZXF1ZXN0LmVycm9yLm1lc3NhZ2V9LmApKSkpO1xuXG4gIH1cblxufVxuIl19